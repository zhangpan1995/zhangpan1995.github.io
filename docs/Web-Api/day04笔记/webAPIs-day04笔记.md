# 学习目标

> - [ ] 能够写出简单发布留言案例
> - [ ] 能够说出什么是事件对象
>
>
> - [ ] 能够获取鼠标在页面内的坐标
> - [ ] 能够说出DOM事件流的三个阶段
> - [ ] 能够写出阻止默认行为和阻止冒泡的代码
> - [ ] 能够利用keyCode判断用户的按键
> 
> 
> 。。。。。。



**理解上课的知识点......**



##### ヾ(๑╹◡╹)ﾉ" 放假倒计时效果

![4000](../../../../../../%E5%BE%80%E5%B1%8A%E6%8E%88%E8%AF%BE/%E4%B8%8A%E6%B5%B7-%E5%B0%B1%E4%B8%9A101%E6%9C%9F%EF%BC%88%E7%9B%B4%E6%92%AD%EF%BC%89/02-webAPIs/day03/01-%E6%95%99%E5%AD%A6%E8%B5%84%E6%96%99/%E7%AC%94%E8%AE%B0/webAPIs-day03%E7%AC%94%E8%AE%B0.assets/4000.gif)

**需求：** 计算距离放假还剩多少时间（格式：xx天xx时xx分xx秒），并且每隔1s更新（倒计时）

**步骤：**

1. 找对象——》天、时、分、秒
2. 计算现在距离放假还剩多少时间
3. 把剩余时间转换成xx天xx时xx分xx秒
4. 把对应的部分设置到页面中的去
5. 使用定时器定时执行逻辑代码



##### ヾ(๑╹◡╹)ﾉ" 微博发布案例

![5000](webAPIs-day04笔记.assets/5000.gif)

**需求1：检测用户输入字数**

1. 找对象：textarean和span
2. 给textarea注册input事件
3. 当用户输入的时候，检测当前文字内容的长度，设置给span

**需求2：当用户点击发布按钮之后，新增一条数据**

1. 找对象：发布按钮和ul#list
2. 给发布按钮注册点击事件
3. 点击之后
   1. 将用户输入的数据获取到储存好
   2. 创建li标签
   3. 往li标签中通过模板字符串添加内容，将字符串中需要变化值进行修改（其中头像和名字需要随机从数组中获取，并且渲染）
   4. 把创建好的li标签添加到ul标签中去（评论一般是最新的加到最前面）
   5. 把textarea中的内容和span的内容清空

**需求3：用户输入如果是空，则不能创建新的li，把内容清空，并且弹框警告**

1. 在点击发布的事件处理函数中，判断用户输入的是否为空（需要使用trim，空格也不行）
2. 如果为空，此时需要阻止事件处理函数继续执行 return
3. 并且弹框告知需要输入数据

**需求4：点击x，需要可以把当前的li标签删除**

1. 需要在创建x之后，再注册点击事件
2. 点击之后，把当前的li删除



**拓展补充：**

- **去除字符串首尾空格方法：** `str.trim()`



# 事件对象

> 例如：完成小天使跟随鼠标移动，设置图片的位置简单，但是我们需要知道鼠标的位置在哪，这时候可以通过事件对象获取。



## 获取事件对象

> 任何一个事件触发时都会有一个事件对象，这个对象中包含所有与事件相关的一些信息，包括事件源、事件类型、鼠标位置、键盘信息等等

**常见情况：**

- 鼠标事件触发时，事件对象中会包含鼠标的位置信息
- 键盘事件触发时，事件对象中会包含按下的键相关的信息

> 不管开发中用没用到事件对象，每一个事件触发时都会有一个事件对象（你用不用，它都在那里）



**既然事件对象中包含事件相关的信息，我们想要用就需要先获取到。**

对于现代浏览器，获取事件对象非常的简单，只需要在注册事件时，为事件处理函数设置一个形参，浏览器会自动将事件对象传递给这个形参，即可获取

```javascript
btn.onclick = function(event){
    //event就是事件对象，里面包含了事件触发时的一些信息。
	console.log(event)
}
// --------------------------------
btn.addEventListener('click',function (event) {
    //event就是事件对象，里面包含了事件触发时的一些信息。
    console.log( event );
})
```



## 事件对象的常用属性

> 事件对象中包含有很多的属性，但是实际开发的时候只需要记住几个常用的即可

### 鼠标事件对象的常见属性

**需求：给div注册点击事件，获取点击时的鼠标坐标位置**

- `type`：获取当前的事件的事件名

- `clientX/clientY`：获取光标相对于浏览器可视区域左上角的水平和垂直坐标

  > 如果有滚动条，不包括被卷去的距离

- `pageX/pageY`：获取光标相对于整个网页左上角的水平和垂直坐标（推荐）

  > 如果有滚动条，包括被卷去的距离

- `offsetX/offsetY`：获取光标相对于当前DOM元素左上角的位置（在border内边界的坐标）

### 键盘事件对象的常用属性

**需求：给input标签注册keyup事件，判断用户输入时按下的是什么键？**

- `key`：
  - 用户按下的按键名
  - 早期使用的是keyCode



![键盘码](webAPIs-day04笔记.assets/keyCode-1593358357858.jpg)



##### ヾ(๑╹◡╹)ﾉ" 小天使跟随鼠标移动案例

> 让img图片的left和top值和光标的坐标一致

**需求：** 让小天使图片在页面中跟随光标移动

![小天使跟随案例](webAPIs-day04笔记.assets/小天使跟随案例-1593358357857.gif)

**步骤：**

1. 给document注册mousemove时间
2. 通过事件对象实时获取鼠标的坐标，设置给图片的left和top值即可

**事件拓展：**

- mousemove：鼠标移动事件



##### ヾ(๑╹◡╹)ﾉ" 微博发布案例-回车发布案例

![222](webAPIs-day04笔记.assets/222.gif)

**需求：** 用户在textarea中按下回车，此时直接发布

**步骤：**

1. 给area注册keyup事件
2. 判断当用户按下的是回车之后，则手动触发send的点击事件，如：send.click()



# 事件流

> 事件冒泡和捕获是普遍存在的现象，需要知道。
>
> 通过事件流可以得知事件执行的顺序。

**事件流：** 指的是事件完整执行过程中的流动路径

**事件的三个阶段：**

1. 事件的**捕获阶段**
2. 事件的**目标阶段**（触发自己的事件）
3. 事件的**冒泡阶段**

![image-20220116011502020](webAPIs-day04笔记.assets/image-20220116011502020.png)



## 事件冒泡

> 当一个元素的事件被触发时，**同类型事件**将会在该元素的所有祖先元素**由内而外中依次被触发**。这一过程被称为事件冒泡。
>
> 事件默认显示的就是事件冒泡过程

**需求：给父子元素都注册点击事件，点击子元素看效果** 

> 其实点击了子元素就相当于点击了父元素，之间存在事件冒泡的流程

```html
<style>
  .father {
    width: 600px;
    height: 600px;
    background-color: pink;
    margin: 0 auto;
  }

  .son {
    width: 400px;
    height: 400px;
    background-color: green;
    margin: 0 auto;
  }

  .sun {
    width: 200px;
    height: 200px;
    background-color: blue;
    margin: 0 auto;
  }
</style>

<div class="father">
  <div class="son">
    <div class="sun"></div>
  </div>
</div>
```

**说白了就是：当我们触发了子元素的某个事件后，父元素对应的事件也会在之后触发** 

![image-20200929113205826](webAPIs-day04笔记.assets/image-20200929113205826.png)



**注意点：事件冒泡默认会一直往上冒泡，不管父元素中有没有同类型的事件处理函数可以触发。**

- 父元素有同类型事件：触发
- 父元素没有同类型事件：没的触发，浏览器会继续往上冒泡不会停止，直到结束。



## 事件捕获（了解）

> 事件捕获是火狐浏览器最早提出来的，IE678不支持事件捕获（基本上我们使用的都是事件冒泡）
>
> 当一个元素的事件被触发时，同样的事件将会在该元素的所有祖先元素**由外而内依次被触发**。这一过程被称为事件捕获。
>
> 可以通过addEventListener的第三个参数设置为true，表示当前事件在捕获阶段触发

![image-20200929115205520](webAPIs-day04笔记.assets/image-20200929115205520.png)

**在后续开发中，我们需要控制父元素的事件是在捕获阶段还是冒泡阶段触发的。此时我们就可以通过控制addEventListener的第三个参数设置事件在什么阶段触发。**

- false：默认值，在冒泡阶段触发
- true：在捕获阶段触发



**需求：给父子元素通过addEventListener注册点击事件，更改第三个参数演示不同阶段触发**

![image-20200929120323898](webAPIs-day04笔记.assets/image-20200929120323898.png)

**注意点：**

- 事件有三个阶段

  - 捕获阶段
  - 目标阶段
  - 冒泡阶段

- 如果是addEventListener，可以通过第三个参数控制事件在什么阶段触发

  > 一般都是冒泡阶段触发，所以第三个参数一般不设置

  - false：默认值，冒泡阶段触发
  - true：捕获阶段触发

- 如果是on注册的事件，默认只在冒泡阶段触发



## 事件对象拓展

### 阻止浏览器默认行为

> 任何事件对象（鼠标事件、键盘事件）都有e.preventDefault()方法，可以用来阻止默认行为
>
> 比如：a标签点击跳转可以通过以上方法阻止



**需求：给a标签注册点击事件，点击之后弹框** 

**解决方法：**

- `return false;` ：可以，但是之后的代码不会执行（不推荐使用）
- `e.preventDefault()` ：可以，并且之后的代码可以执行（推荐使用）

---

**注意点：针对于addEventListener注册事件的方式，需要使用e.preventDefault()才能阻止默认行为**

**补充：**阻止a标签的跳转还有一种常见的方式可以写这么写：

```html
<!-- 表示点击a标签之后，不去跳转，去执行js代码——》void(0)表示什么都不做，可以省略。-->
<a href="javascript:;">我是一个a标签</a>
```



### 阻止事件冒泡

> 可以通过e.stopPropagation()方法可以阻止事件的下一步传播，常用于阻止事件冒泡
>
> 阻止事件冒泡，就可以将事件限定在当前元素内

**需求：给father和son分别注册点击事件，需要点击father只触发father的事件，点击son只触发son的事件** 

```html
<style>
  .father {
    width: 600px;
    height: 600px;
    background-color: pink;
    margin: 0 auto;
  }

  .son {
    width: 400px;
    height: 400px;
    background-color: green;
    margin: 0 auto;
  }
</style>

<div class="father">
  <div class="son"></div>
</div>
```



# 事件委托

> 事件委托：是利用事件流的特征解决一些开发需求的知识技巧

**需求：让每个li标签点击之后，让当前li标签的文字变红**

**优点：** 给父级元素加事件（可以提高性能）

**原理：** 事件委托其实是利用事件冒泡的特点， 给父元素添加事件，子元素可以触发

**实现：** `事件对象.target` 可以获得真正触发事件的元素

```js
// 方法1，找到每一个li标签，给每一个li标签注册点击事件---------------------------------
let lis = document.querySelectorAll('li')
// 给每一个li注册点击事件
for (let i = 0; i < lis.length ; i++) {
    lis[i].addEventListener('click',function () {
        this.style.color = 'red'
    })
}

// 方法2：利用事件委托，只需要找ul，给ul一个标签注册一个点击事件即可----------------------------
let ul = document.querySelector('ul')
ul.addEventListener('click',function (e) {
    e.target.style.color = 'blue'
})
```



# 移除事件的两种方式（了解）

> 除了可以给元素注册事件之外，还可以移除元素身上原有的事件

**需求：给button注册点击事件，然后通过代码移除事件**

## on+事件名=null

> 对于on注册的事件，直接把之前的事件覆盖即可

```js
btn.onclick = null;
```



## removeEventListener('事件名称'，函数名)

> 对于addEventListener注册的事件，需要使用特定的方法移除

```javascript
// 第一个参数：事件的类型
// 第二个参数：要移除的函数名
removeEventListener(type, func);
```

**注意点：**如果想要让你注册的事件之后能够移除，不能使用匿名函数。要声明一个有名字的函数使用。



# 数组常见相关方法

## 数组的增删操作（push、pop、unshift、shift）

```javascript
let arr = ['张三','李四','王五','赵六']

// --------------------在数组的最后，添加一个或多个项，返回添加后数组的length
arr.push()
// -------------------在数组的最后，删除一项，返回删除的项
arr.pop()
// --------------------在数组的最前面，添加一个或多个项，返回添加后数组的length
arr.unshift()
// ---------------------在数组的最前面，删除一项，返回删除的项
arr.shift()
```

##### ヾ(๑╹◡╹)ﾉ" 数组的增删操作练习

  ```js
//练习1
let arr = ["刘备"]
//添加数据后变成：["赵云","马超","刘备","关羽","张飞"]

//接着删除数据后变成：["关羽","张飞"]

console.log(arr)

//练习2
let arr = ["赵云","马超","刘备","关羽","张飞"]
//把数组的最后一个元素变成数组的第一个元素

//把数组的第一个元素变成数组的最后一个元素

console.log(arr)
  ```



## 数组的删除、添加、替换：splice

> splice可以在数组的任意位置，添加或者删除任意项，会改变原数组

```js
//------------------splice 方法可以在数组的任意位置，添加或者删除任一项（会改变原数组）
arr.splice(从哪开始删除，删除几个，添加的项1，添加的项2，......)
arr.splice(begin,deleteCount,item1,item2,...)

let arr = ["赵云","马超","刘备","关羽","张飞"]         
           
//删除--------------------从下标为1开始删除，删除两项
arr.splice(1,2) // 删除

//添加--------------------把第一项、第二项添加到下标2的位置
arr.splice(2,0,'第一项','第二项') // 添加

//替换--------------------把下标2这一项替换成新项（先删除，再添加）
arr.splice(2,1,'新项') // 替换
```

#####  ヾ(๑╹◡╹)ﾉ" 数组的练习

  ```js
//练习：
let arr = ["赵云","马超","刘备","关羽","张飞"] 
// 1、在马超后面增加 马腾
// 2、删除关羽
  ```



# 综合案例

##### ヾ(๑╹◡╹)ﾉ" 渲染学生信息案例

![image-20220116013155475](webAPIs-day04笔记.assets/image-20220116013155475.png)

**说明：** 本次案例使用思路是 **数据操作视图**，是为了之后学习Vue铺垫，并不是直接操作dom（用直接操作dom会更简单，但是目的是为了铺垫就业重要框架Vue），同学们能按照老师思路步骤写出来案例即可，目前感知不深，但后期vue是就是数据操作视图

**逻辑：** 无论是添加还是删除，都是先操作数据数组，然后重新渲染数组数据到页面

**功能1：把数据渲染到页面中去**

1. 找对象——》找到需要操作的tbody
2. 遍历当前的数据数组，每遍历一项，则创建一项tr标签
3. 往tr中通过模板字符串添加内容
4. 把创建好的tr标签添加到tbody中去
5. 需要数组中的数据动态渲染到模板字符串中
6. 防止html结构中原本就存在的tr，可以在最开始渲染之前，先把tbody的内容清空（设置内容为空字符串）
7. 优化：封装函数：因为本案例是数据操作视图，整体逻辑就是：先修改数据数组，然后重新渲染数组，因此会经常用到渲染数组，因此封装函数，可以一次声明多次调用
8. 一打开页面先调用render函数，把数组数据渲染到页面中去

**功能2：点击录入按钮之后，把数据添加到数组中，然后把数组中数据渲染到页面中去**

1. 找对象——》找到录入按钮、5个表单标签
2. 给录入按钮注册点击事件
3. 点击之后，获取5个表单标签的数据，组装成数据数组中每一项的对象格式
4. 注意点：用户并没有输入学号，学号的做法是获取到数据数组的最后一项的stuId，然后+1设置的
5. 把组装好的对象格式，push添加到数据数组中去
6. 把添加之后的数据数组重新渲染——》调用渲染函数render即可
7. 添加渲染完数据之后，记得把5个表单标签重新回复成默认值

**功能3：如果点击的录入的时候，三个输入框中有一个没输入数据，则弹框请输入数据，并且不录入**

1. 录入按钮的点击事件一开始，就判断三个输入框是否有一个没输入
2. 如果有一个没输入，则弹框提示，清空三个输入框，结束当前事件处理函数



**功能4：点击删除a标签之后，把数据数组中对应的数据删除掉，然后重新渲染数据数组**

1. 直接找a标签会找很多，而且还需要等a标签创建出来之后，才能注册事件麻烦，此时我们会使用事件委托优化代码——》给一个父元素注册点击事件，利用事件冒泡，判断如果是a标签，则清除对应的数据数组再渲染
2. 找对象——》找到父元素tbody
3. 给tbody注册点击事件
4. 点击的时候，判断触发事件的标签是不是a标签 e.target.tagName
5. 如果触发事件的是标签就是a标签，则通过a标签身上的id属性（把当前渲染数据数组下标储存到a标签身上，这样可以直接知道当前是第几个li中的a标签）
6. 通过数组删除方法arr.splice()方法删除对应的数组中的数据
7. 使用渲染函数render() 重新渲染数据

